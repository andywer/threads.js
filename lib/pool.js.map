{"version":3,"sources":["pool.js"],"names":[],"mappings":"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","file":"pool.js","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport Job          from './job';\nimport defaults     from './defaults';\nimport { spawn }    from './';\n\nexport default class Pool extends EventEmitter {\n  constructor(threads) {\n    super();\n    this.threads = Pool.spawn(threads || defaults.pool.size);\n    this.idleThreads = this.threads.slice();\n    this.jobQueue = [];\n    this.lastCreatedJob = null;\n\n    this.on('newJob', this.handleNewJob.bind(this));\n  }\n\n  run(...args) {\n    return (new Job(this)).run(...args);\n  }\n\n  send(...args) {\n    if (!this.lastCreatedJob) {\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\n    }\n\n    // this will not alter the last job, but rather clone it and set this params on the new job\n    return this.lastCreatedJob.send(...args);\n  }\n\n  killAll() {\n    this.threads.forEach(thread => {\n      thread.kill();\n    });\n  }\n\n  queueJob(job) {\n    this.jobQueue.push(job);\n    this.dequeue();\n  }\n\n  dequeue() {\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\n      return;\n    }\n\n    const job = this.jobQueue.shift();\n    const thread = this.idleThreads.shift();\n\n    job\n      .on('done', this.handleJobSuccess.bind(this, thread, job))\n      .on('error', this.handleJobError.bind(this, thread, job));\n\n    job.executeOn(thread);\n  }\n\n  handleNewJob(job) {\n    this.lastCreatedJob = job;\n    job.on('readyToRun', this.queueJob.bind(this, job));    // triggered by job.send()\n  }\n\n  handleJobSuccess(thread, job, ...responseArgs) {\n    this.emit('done', job, ...responseArgs);\n    this.handleJobDone(thread);\n  }\n\n  handleJobError(thread, job, error) {\n    this.emit('error', job, error);\n    this.handleJobDone(thread);\n  }\n\n  handleJobDone(thread) {\n    this.idleThreads.push(thread);\n    this.dequeue();\n\n    if (this.idleThreads.length === this.threads.length) {\n      // run deferred to give other job.on('done') handlers time to run first\n      setTimeout(() => { this.emit('finished'); }, 0);\n    }\n  }\n}\n\nPool.spawn = (threadCount) => {\n  const threads = [];\n\n  for (let threadIndex = 0; threadIndex < threadCount; threadIndex++) {\n    threads.push(spawn());\n  }\n\n  return threads;\n};\n"],"sourceRoot":"/source/"}